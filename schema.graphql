# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: QueryType
    mutation: MutationType
}

"File/image attachments"
type AppAttachment {
    "Description of the attachment, might be former filename"
    description: String
    "attachment id"
    id: String!
    "Attachment media type"
    type: String!
    "Attachment url as alternative to binary content"
    url: String
}

"Data-base backed attachments"
type AppAttachmentData {
    "DB column 'attachment_id'"
    attachmentId: String!
    "attachement as binary data"
    data: [Byte]!
    "attachment data id"
    id: String!
}

"Database backing for the AppScope"
type AppConfig {
    "Application name"
    name: String!
    "JSON of the current application scope"
    scope: JSONB!
}

"Database storage for spring security's remember-me feature"
type AppLogin {
    "Last access of the login"
    lastUsed: Timestamp!
    "Token series"
    series: String!
    "Token"
    token: String!
    "User name of the login"
    username: String!
}

"Datase backing for the application translations"
type AppTranslation {
    "creation date of the translation entry"
    created: Timestamp!
    "translation id"
    id: String!
    "locale code of the translation'"
    locale: String!
    "last modified date for the translation entry"
    modified: Timestamp!
    "can contain a process name to limit the to just that process"
    processName: String!
    "translation tag/key"
    tag: String!
    "translation text"
    translation: String!
}

"Application users. Used to authenticate users by spring security. Can have additional fields/relations (See UserInfoService)"
type AppUser {
    "Many-to-many objects from baz.owner_id"
    bazes: [Baz]!
    "Creation date of the user entry"
    created: Timestamp!
    "true if the user account was disabled"
    disabled: Boolean
    "Many-to-many objects from foo.owner_id"
    foos: [Foo]!
    "user database id"
    id: String!
    "last login of the user"
    lastLogin: Timestamp
    "User name / login"
    login: String!
    "encrypted password"
    password: String!
    "Spring security roles of the user within the application"
    roles: String!
}

"Database backing for the UserScope"
type AppUserConfig {
    "DB column 'attachment_id'"
    attachmentId: String!
    "DB column 'login'"
    login: String!
    "DB column 'user_id'"
    userId: String!
}

"Stores merge version metadata"
type AppVersion {
    "Timestamp when the version was created"
    created: Timestamp!
    "Id of the entity"
    entityId: String!
    "Entity type the version refers to"
    entityType: String!
    "DB column 'field_mask'"
    fieldMask: BigInteger!
    "Id of the version. Is the same as the version field in the entity."
    id: String!
    "Target of 'owner_id'"
    owner: AppUser!
    "DB foreign key column 'owner_id'"
    ownerId: String!
    "Previous version for that entity or null"
    prev: String
}

"Domain object used in ext-filter-test. Generated from public.bar in the database dump."
type Bar {
    "DB column 'created'"
    created: Timestamp
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "DB column 'numa'"
    numa: Int!
    "DB column 'numb'"
    numb: Int!
}

"Associated Entity A (see BazLink)"
type Baz {
    "Many-to-many objects from baz_link.baz_id"
    bazLinks: [BazLink]!
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "Target of 'owner_id'"
    owner: AppUser!
    "DB foreign key column 'owner_id'"
    ownerId: String!
}

"Associative entity m-to-n connecting Baz and BazValue"
type BazLink {
    "Target of 'baz_id'"
    baz: Baz!
    "DB foreign key column 'baz_id'"
    bazId: String!
    "DB column 'id'"
    id: String!
    "Target of 'value_id'"
    value: BazValue!
    "DB foreign key column 'value_id'"
    valueId: String!
}

"Associated Entity B (see BazLink)"
type BazValue {
    "Many-to-many objects from baz_link.value_id"
    bazLinks: [BazLink]!
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
}

"Generated for java.math.BigInteger"
type BigInteger {
    lowestSetBit: Int
}

"The state of a column within an interactive query."
type ColumnState {
    "True if column is enabled. Server might disabled columns."
    enabled: Boolean
    "Column name"
    name: String
    "True if the column is sortable."
    sortable: Boolean
}

"Type complex used in merge-test"
type Corge {
    "Many-to-many objects from corge_link.corge_id"
    corgeLinks: [CorgeLink]!
    "DB column 'created'"
    created: Timestamp!
    "DB column 'description'"
    description: String
    "DB column 'flag'"
    flag: Boolean!
    "DB column 'id'"
    id: String!
    "DB column 'modified'"
    modified: Timestamp!
    "DB column 'name'"
    name: String!
    "DB column 'num'"
    num: Int!
    "DB column 'num2'"
    num2: Int
    "Target of 'owner_id'"
    owner: AppUser!
    "DB foreign key column 'owner_id'"
    ownerId: String!
    "Target of 'type_id'"
    type: CorgeType!
    "DB foreign key column 'type2'"
    type2: String!
    "Target of 'type2'"
    type2Obj: CorgeType!
    "DB foreign key column 'type_id'"
    typeId: String!
    "DB column 'version'"
    version: String!
}

"Many-to-many associated type to Corge"
type CorgeAssoc {
    "Many-to-many objects from corge_link.assoc_id"
    corgeLinks: [CorgeLink]!
    "DB column 'description'"
    description: String
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "DB column 'num'"
    num: Int!
    "DB column 'version'"
    version: String!
}

"Many-to-many link type between Corge and CorgeAssoc"
type CorgeLink {
    "Target of 'assoc_id'"
    assoc: CorgeAssoc!
    "DB foreign key column 'assoc_id'"
    assocId: String!
    "Target of 'corge_id'"
    corge: Corge!
    "DB foreign key column 'corge_id'"
    corgeId: String!
    "DB column 'id'"
    id: String!
    "DB column 'version'"
    version: String!
}

"Type of Corges, connected via relation"
type CorgeType {
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
}

"Reference to a specific entity or entity version"
type EntityReference {
    id: GenericScalar!
    type: String!
    version: String
}

"Generic domain object. Used as target in datagrid-test. Generated from public.foo in the database dump."
type Foo {
    "DB column 'created'"
    created: Timestamp!
    "DB column 'description'"
    description: String
    "DB column 'flag'"
    flag: Boolean!
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "DB column 'num'"
    num: Int!
    "Target of 'owner_id'"
    owner: AppUser!
    "DB foreign key column 'owner_id'"
    ownerId: String!
    "DB foreign key column 'type'"
    type: String!
}

"Catalog-like domain object, referenced by Foo. Generated from public.foo_type in the database dump."
type FooType {
    "DB column 'name'"
    name: String!
    "DB column 'ordinal'"
    ordinal: Int!
}

"Container bean for the file/resource example."
type Fred {
    items: [FredItem]
    name: String!
}

"Item within a Fred"
type FredItem {
    flag: Boolean
    name: String!
    value: Int
}

"Entity containing BigDecimal fields"
type Garply {
    "garply id"
    id: String!
    "garply name"
    name: String!
    "optional big decimal field"
    opt: BigDecimal
    "big decimal field"
    value: BigDecimal!
}

"Generated from public.grault"
type Grault {
    "Target of 'attachment_id'"
    attachment: AppAttachment
    "DB foreign key column 'attachment_id'"
    attachmentId: String
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "DB column 'url'"
    url: String
}

"Generated from public.grid_columns"
type GridColumns {
    "DB column 'columns'"
    columns: JSONB
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "DB column 'owner_id'"
    ownerId: String!
}

"Interactive Query with AppUser payload."
type InteractiveQueryAppUser {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of AppUser."
    rows: [AppUser]
    "Name of payload type (always 'AppUser')"
    type: String
}

"Interactive Query with Bar payload."
type InteractiveQueryBar {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of Bar."
    rows: [Bar]
    "Name of payload type (always 'Bar')"
    type: String
}

"Interactive Query with Baz payload."
type InteractiveQueryBaz {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of Baz."
    rows: [Baz]
    "Name of payload type (always 'Baz')"
    type: String
}

"Interactive Query with BazLink payload."
type InteractiveQueryBazLink {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of BazLink."
    rows: [BazLink]
    "Name of payload type (always 'BazLink')"
    type: String
}

"Interactive Query with BazValue payload."
type InteractiveQueryBazValue {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of BazValue."
    rows: [BazValue]
    "Name of payload type (always 'BazValue')"
    type: String
}

"Interactive Query with Corge payload."
type InteractiveQueryCorge {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of Corge."
    rows: [Corge]
    "Name of payload type (always 'Corge')"
    type: String
}

"Interactive Query with CorgeAssoc payload."
type InteractiveQueryCorgeAssoc {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of CorgeAssoc."
    rows: [CorgeAssoc]
    "Name of payload type (always 'CorgeAssoc')"
    type: String
}

"Interactive Query with CorgeLink payload."
type InteractiveQueryCorgeLink {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of CorgeLink."
    rows: [CorgeLink]
    "Name of payload type (always 'CorgeLink')"
    type: String
}

"Interactive Query with CorgeType payload."
type InteractiveQueryCorgeType {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of CorgeType."
    rows: [CorgeType]
    "Name of payload type (always 'CorgeType')"
    type: String
}

"Container for user-editable interactive query definition. Wraps a query string and a default query config."
type InteractiveQueryDefinition {
    query: String
    queryConfig: QueryConfig
}

"Interactive Query with Foo payload."
type InteractiveQueryFoo {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of Foo."
    rows: [Foo]
    "Name of payload type (always 'Foo')"
    type: String
}

"Interactive Query with FooType payload."
type InteractiveQueryFooType {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of FooType."
    rows: [FooType]
    "Name of payload type (always 'FooType')"
    type: String
}

"Interactive Query with Garply payload."
type InteractiveQueryGarply {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of Garply."
    rows: [Garply]
    "Name of payload type (always 'Garply')"
    type: String
}

"Interactive Query with Grault payload."
type InteractiveQueryGrault {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of Grault."
    rows: [Grault]
    "Name of payload type (always 'Grault')"
    type: String
}

"Interactive Query with MetaConfig payload."
type InteractiveQueryMetaConfig {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of MetaConfig."
    rows: [MetaConfig]
    "Name of payload type (always 'MetaConfig')"
    type: String
}

"Interactive Query with Node payload."
type InteractiveQueryNode {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of Node."
    rows: [Node]
    "Name of payload type (always 'Node')"
    type: String
}

"Interactive Query with Plugh payload."
type InteractiveQueryPlugh {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of Plugh."
    rows: [Plugh]
    "Name of payload type (always 'Plugh')"
    type: String
}

"Interactive Query with QuxA payload."
type InteractiveQueryQuxA {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of QuxA."
    rows: [QuxA]
    "Name of payload type (always 'QuxA')"
    type: String
}

"Interactive Query with QuxB payload."
type InteractiveQueryQuxB {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of QuxB."
    rows: [QuxB]
    "Name of payload type (always 'QuxB')"
    type: String
}

"Interactive Query with QuxC payload."
type InteractiveQueryQuxC {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of QuxC."
    rows: [QuxC]
    "Name of payload type (always 'QuxC')"
    type: String
}

"Interactive Query with QuxD payload."
type InteractiveQueryQuxD {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of QuxD."
    rows: [QuxD]
    "Name of payload type (always 'QuxD')"
    type: String
}

"Interactive Query with QuxE payload."
type InteractiveQueryQuxE {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of QuxE."
    rows: [QuxE]
    "Name of payload type (always 'QuxE')"
    type: String
}

"Interactive Query with QuxMain payload."
type InteractiveQueryQuxMain {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of QuxMain."
    rows: [QuxMain]
    "Name of payload type (always 'QuxMain')"
    type: String
}

"Interactive Query with QuxTop payload."
type InteractiveQueryQuxTop {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of QuxTop."
    rows: [QuxTop]
    "Name of payload type (always 'QuxTop')"
    type: String
}

"Interactive Query with SumPerMonth payload."
type InteractiveQuerySumPerMonth {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of SumPerMonth."
    rows: [SumPerMonth]
    "Name of payload type (always 'SumPerMonth')"
    type: String
}

"Interactive Query with Waldo payload."
type InteractiveQueryWaldo {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of Waldo."
    rows: [Waldo]
    "Name of payload type (always 'Waldo')"
    type: String
}

"A merge conflict for one entity."
type MergeConflict {
    "Returns true if all conflict fields are decided or if there are no conflict fields."
    decided: Boolean
    "True if the entity has been deleted on the other side"
    deleted: Boolean!
    """

    Conflicted fields. Will be both conflicts on scalar fields as well as conflicts on object fields representing
    foreign key and many-to-many conflicts and the informational/user-facing data to resolve those.
    """
    fields: [MergeConflictField]!
    "Id of the entity as generic scalar"
    id: GenericScalar!
    "The version of the currently stored entity."
    theirVersion: String
    "Type of the entity."
    type: String!
}

"A field within a merge conflict."
type MergeConflictField {
    """

    True if the conflict is only sent for informational purposes and for the "apply" function. It marks conflicts
    that are already resolved.
    """
    informational: Boolean
    name: String!
    "The user's value for the conflict."
    ours: GenericScalar
    """

    In case of a pseudo conflict on a many-to-many field this contains entity references to the current set of link
    type entities.
    """
    references: [EntityReference]
    "Field status for the conflict."
    status: MergeFieldStatus
    "The currently stored value for the conflict."
    theirs: GenericScalar
}

"Encapsulates the result of a merge operation. Used in-memory on the client-side."
type MergeResolution {
    "Operation selected by the user."
    operation: MergeResolutionOperation
    "Resolutions to apply to the working set."
    resolutions: [MergeResolutionEntity]!
}

"Encapsulates the merge resolution for one of the entities involved. Used in-memory on the client-side."
type MergeResolutionEntity {
    deleted: Boolean!
    fields: [MergeResolutionField]!
    id: GenericScalar!
    type: String!
    version: String
}

"Encapsulates the merge resolution of a single field. Used in-memory on the client-side."
type MergeResolutionField {
    fieldType: MergeResolutionFieldType
    "GraphQL name of the field."
    name: String!
    status: MergeFieldStatus!
    "Wrapped value"
    value: GenericScalar
}

"Encapsulates the result of a merge process, i.e. a list of domain object conflicts."
type MergeResult {
    conflicts: [MergeConflict]!
    "Returns true when the merge is done because there were no conflicts."
    done: Boolean
}

"Container type to test <FieldMetaButton/> on different field types"
type MetaConfig {
    "Target of 'attachment_id'"
    attachment: AppAttachment
    "DB foreign key column 'attachment_id'"
    attachmentId: String
    "DB column 'big_num'"
    bigNum: BigDecimal
    "Target of 'corge_type_id'"
    corgeType: CorgeType
    "DB foreign key column 'corge_type_id'"
    corgeTypeId: String
    "DB column 'date'"
    date: Date
    "DB column 'flag'"
    flag: Boolean
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "DB column 'num'"
    num: Int
    "DB column 'text'"
    text: String
    "DB column 'timestamp'"
    timestamp: Timestamp
    "DB foreign key column 'type'"
    type: String
    "DB column 'url'"
    url: String
}

"Auto-generated from DataGridLogic, FileAccessLogic, ResourceAccessLogic, ResultTestLogic, ShippingLogic, TestLogic, AutomatonStandardLogic"
type MutationType {
    complexStore(container: ComplexContainerInput): Boolean
    "Example for Datagrid column configuration. Stores columns in public.grid_columns"
    configureColumns(columns: JSONB, name: String!): Boolean
    createFoo(name: String!): Foo
    "Deletes the domain object of the given type and with the given id."
    deleteDomainObject(cascade: [String], id: GenericScalar!, type: String!): Boolean
    fiftyFifty(delay: Boolean): String
    "Generate a new domain object id using the application specific IdGenerator implementation."
    generateDomainObjectId(count: Int = 1, domainType: String!): [GenericScalar]
    "Server-side end-point for WorkingSet.merge()"
    mergeWorkingSet(changes: [EntityChangeInput]!, deletions: [EntityDeletionInput]!, mergeConfig: MergeConfigInput): MergeResult
    "Server-side end-point for WorkingSet.persist()"
    persistWorkingSet(deletions: [EntityDeletionInput]!, domainObjects: [DomainObject]!): Boolean
    "Dummy end-point to define the types involved in resolving a merge conflict, which happens on the client side only. This is only exists for documentation purposes."
    resolveMerge(mergeConfig: MergeConfigInput, mergeConflict: MergeConflictInput): MergeResolution
    resultError(delay: Boolean): ResultString
    resultInfo(delay: Boolean): ResultFoo
    resultSilent(delay: Boolean): ResultString
    resultWarning(delay: Boolean): ResultString
    "Stores a single domain object of any type. Note that you might have to manually register an input type."
    storeDomainObject(domainObject: DomainObject!): GenericScalar
    "Stores a list of domain object of any type. Note that you might have to manually register an input type."
    storeDomainObjects(domainObjects: [DomainObject]!): [GenericScalar]
    "Updates the associations of one source domain object over a many-to-many connection / an associative entity"
    updateAssociations(domainObjects: [DomainObject]!, domainType: String!, leftSideRelation: String!, sourceIds: [GenericScalar]!): [GenericScalar]
    "Updates the fred.json file with the new content from a Fred instance via raw file IO"
    updateFredFile(fred: FredInput): Boolean
    """

    Updates the fred.json resource/file with the new content from a Fred instance.

    <p>
    We can only have write access if the application is deployed as "exploded WAR". In cases of a WAR deployment, all
    servlet resources are read via input stream and don't allow updates.
    </p>
    """
    updateFredResource(fred: FredInput): Boolean
    wireTestMutation(count: Int, input: FooInput): WireTestResult
}

"Recursive domain object used in animal-test. Generated from public.node in the database dump."
type Node {
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "Target of 'parent_id'"
    parent: Node
    "DB column 'type'"
    type: Int!
}

"Generated for de.quinscape.domainql.util.Paged<Foo>"
type PagedFoo {
    rowCount: Int!
    rows: [Foo]!
}

type Plugh {
    "DB column 'created'"
    created: Timestamp!
    "DB column 'description'"
    description: String
    extra: String
    "DB column 'flag'"
    flag: Boolean!
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "DB column 'num'"
    num: Int!
    "Target of 'owner_id'"
    owner: AppUser!
    "DB foreign key column 'owner_id'"
    ownerId: String!
}

"Encapsulates all parameters of an interactive query."
type QueryConfig {
    "FilterDSL condition graph or null"
    condition: Condition
    "Optional unique query identifier. Useful for server-side query implementations."
    id: String
    "Current offset within the paginated results. The number of rows to skip in the results."
    offset: Int
    "Maximum number of paginated results.,"
    pageSize: Int
    "Current sort order for the query."
    sortFields: [FieldExpression]
}

"Auto-generated from DataGridLogic, FileAccessLogic, ResourceAccessLogic, ResultTestLogic, ShippingLogic, TestLogic, AutomatonStandardLogic"
type QueryType {
    _interactiveQueryDefinition(def: InteractiveQueryDefinitionInput): InteractiveQueryDefinition
    getDomainTypeIndex(condition: Condition, domainType: String!, field: String!): [String]
    getFoos(limit: Int = 10, offset: Int = 0): PagedFoo
    """

    Returns the current content of the fred.json via raw file access.
    <p>
    This method will re-read and reparse the fred.json file on *every* invocation.
    </p>
    """
    getFredFile: Fred
    """

    Returns the current content of the fred.json resource/file as Fred instance.
    <p>
    The resource handle mechanism makes sure we only reload and reparse fred.json when
    the file changed.
    </p>
    <p>
    The resource loader system internally creates a file watch service that asynchronously listens to file change
    events and throws away stale resource content. The next call to .getContent() will then reread and
    reparse the content.
    </p>
    """
    getFredResource: Fred
    "Alternate iQuery method for Bar"
    iQueryAlternateBar(config: QueryConfigInput!): InteractiveQueryBar
    "Alternate iQuery method for Foo"
    iQueryAlternateFoo(config: QueryConfigInput!): InteractiveQueryFoo
    "Queries AppUser objects based on the given query config"
    iQueryAppUser(config: QueryConfigInput!): InteractiveQueryAppUser
    "Queries Bar objects based on the given query config"
    iQueryBar(config: QueryConfigInput!): InteractiveQueryBar
    "Queries Baz objects based on the given query config"
    iQueryBaz(config: QueryConfigInput!): InteractiveQueryBaz
    "Queries BazLink objects based on the given query config"
    iQueryBazLink(config: QueryConfigInput!): InteractiveQueryBazLink
    "Queries BazValue objects based on the given query config"
    iQueryBazValue(config: QueryConfigInput!): InteractiveQueryBazValue
    "Queries Corge objects based on the given query config"
    iQueryCorge(config: QueryConfigInput!): InteractiveQueryCorge
    "Queries CorgeAssoc objects based on the given query config"
    iQueryCorgeAssoc(config: QueryConfigInput!): InteractiveQueryCorgeAssoc
    "Queries CorgeLink objects based on the given query config"
    iQueryCorgeLink(config: QueryConfigInput!): InteractiveQueryCorgeLink
    "Queries CorgeType objects based on the given query config"
    iQueryCorgeType(config: QueryConfigInput!): InteractiveQueryCorgeType
    "Queries Foo objects based on the given query config"
    iQueryFoo(config: QueryConfigInput!): InteractiveQueryFoo
    "Queries FooType objects based on the given query config"
    iQueryFooType(config: QueryConfigInput!): InteractiveQueryFooType
    "Queries Garply objects based on the given query config"
    iQueryGarply(config: QueryConfigInput!): InteractiveQueryGarply
    "Queries Grault objects based on the given query config"
    iQueryGrault(config: QueryConfigInput!): InteractiveQueryGrault
    "Queries MetaConfig objects based on the given query config"
    iQueryMetaConfig(config: QueryConfigInput!): InteractiveQueryMetaConfig
    "Queries Node objects based on the given query config"
    iQueryNode(config: QueryConfigInput!): InteractiveQueryNode
    "Queries Plugh objects based on the given query config"
    iQueryPlugh(config: QueryConfigInput!): InteractiveQueryPlugh
    "Queries QuxA objects based on the given query config"
    iQueryQuxA(config: QueryConfigInput!): InteractiveQueryQuxA
    "Queries QuxB objects based on the given query config"
    iQueryQuxB(config: QueryConfigInput!): InteractiveQueryQuxB
    "Queries QuxC objects based on the given query config"
    iQueryQuxC(config: QueryConfigInput!): InteractiveQueryQuxC
    "Queries QuxD objects based on the given query config"
    iQueryQuxD(config: QueryConfigInput!): InteractiveQueryQuxD
    "Queries QuxE objects based on the given query config"
    iQueryQuxE(config: QueryConfigInput!): InteractiveQueryQuxE
    "Queries QuxMain objects based on the given query config"
    iQueryQuxMain(config: QueryConfigInput!): InteractiveQueryQuxMain
    "Queries QuxTop objects based on the given query config"
    iQueryQuxTop(config: QueryConfigInput!): InteractiveQueryQuxTop
    "Queries SumPerMonth objects based on the given query config"
    iQuerySumPerMonth(config: QueryConfigInput!): InteractiveQuerySumPerMonth
    "Queries Waldo objects based on the given query config"
    iQueryWaldo(config: QueryConfigInput!): InteractiveQueryWaldo
    iQuerywithColumnConfigFoo(config: QueryConfigInput): InteractiveQueryFoo
    queryWithComplexList: [Foo]
    queryWithList: [Int]
    queryWithScalar: Timestamp
    """

    Resolves filter context values without executing them in a filter. Only use this if you need the actual values of
    filter contexts on the client side. The normal usage of context values is to embed <code>context()</code> nodes
    in filters.
    """
    resolveFilterContext(names: [String]!): [GenericScalar]
}

"Catalog-like connected via id foreign key to QuxMain"
type QuxA {
    "DB column 'description'"
    description: String
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "DB column 'value'"
    value: Int!
}

"Catalog-like connected via name foreign key to QuxMain"
type QuxB {
    "DB column 'description'"
    description: String
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "DB column 'value'"
    value: Int!
}

"Catalog-like connected via id foreign keys to QuxMain twice"
type QuxC {
    "DB column 'description'"
    description: String
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "DB column 'value'"
    value: Int!
}

"Catalog-like connected via id foreign QuxMain without scalar field"
type QuxD {
    "DB column 'description'"
    description: String
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "DB column 'value'"
    value: Int!
}

"Catalog-like connected via id foreign key to QuxMid"
type QuxE {
    "DB column 'description'"
    description: String
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "DB column 'value'"
    value: Int!
}

"Main object for fk_test"
type QuxMain {
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "Target of 'qux_a_id'"
    quxA: QuxA!
    "DB foreign key column 'qux_a_id'"
    quxAId: String!
    "Target of 'qux_b_name'"
    quxB: QuxB
    "DB foreign key column 'qux_b_name'"
    quxBName: String
    "Target of 'qux_c_id1'"
    quxC1: QuxC!
    "Target of 'qux_c_id2'"
    quxC2: QuxC
    "DB foreign key column 'qux_c_id1'"
    quxCId1: String!
    "DB foreign key column 'qux_c_id2'"
    quxCId2: String
    "Target of 'qux_d_id'"
    quxD: QuxD
    "Target of 'qux_d2_id'"
    quxD2: QuxD
    "DB foreign key column 'qux_d2_id'"
    quxD2Id: String
    "Target of 'qux_d3_id'"
    quxD3: QuxD
    "DB foreign key column 'qux_d3_id'"
    quxD3Id: String
    "Target of 'qux_d4_id'"
    quxD4: QuxD
    "DB foreign key column 'qux_d4_id'"
    quxD4Id: String
    "DB foreign key column 'qux_d_id'"
    quxDId: String
}

"Mid level object for two-step fk_test."
type QuxMid {
    "DB column 'description'"
    description: String
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "Target of 'qux_e_id'"
    quxE: QuxE
    "DB foreign key column 'qux_e_id'"
    quxEId: String
}

"Top level object for two-step fk_test. Has a 1-to-1 relation to QuxMid"
type QuxTop {
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "Target of 'qux_mid_id'"
    quxMid: QuxMid!
    "DB foreign key column 'qux_mid_id'"
    quxMidId: String!
}

"Generic result wrapper. Allows client-side code to register post-processors based on it."
type ResultFoo {
    "Returns the payload of type Foo"
    payload: Foo
    "Returns the result type."
    type: ResultType
}

"Generic result wrapper. Allows client-side code to register post-processors based on it."
type ResultString {
    "Returns the payload of type String"
    payload: String
    "Returns the result type."
    type: ResultType
}

"Domain object from Java POJO de.quinscape.automatontest.model.SumPerMonth shaped like the sum_per_month view in the database dump"
type SumPerMonth {
    "DB column 'month'"
    month: Int
    "DB column 'sum'"
    sum: Long
    "DB column 'year'"
    year: Int
}

"Generated from public.waldo"
type Waldo {
    "DB column 'date'"
    date: Date!
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "DB column 'opt1'"
    opt1: Timestamp
    "DB column 'opt2'"
    opt2: Date
    "DB column 'timestamp'"
    timestamp: Timestamp!
}

"Generated for de.quinscape.automatontest.runtime.service.TestLogic$WireTestResult"
type WireTestResult {
    check: String
    created: Timestamp
    id: String
}

enum FieldMode {
    DISABLED
    INVISIBLE
    NORMAL
    PLAIN_TEXT
    READ_ONLY
}

enum MergeFieldStatus {
    "We took the original value."
    OURS
    "We took over the current database value"
    THEIRS
    "User has not yet decided."
    UNDECIDED
    "The user specified an alternate third value."
    VALUE
}

enum MergeResolutionFieldType {
    "Normal input field"
    FIELD
    "Foreign key raw key id field"
    FK_KEY
    "Embedded object for a foreign key"
    FK_OBJECT
    "Ignored field"
    IGNORE
    "Embedded list of objects for a m-to-n relation"
    MANY_TO_MANY
}

"User selected operation for a merge"
enum MergeResolutionOperation {
    """

    The merge resolutions are to be applied without executing the final store operation. The user can inspect the merge
    result in the original form context.
    """
    APPLY
    "The store operation was canceled. The working set remains as-is."
    CANCEL
    "The whole process is aborted and the current working set data is to be discarded."
    DISCARD
    "Merge resolutions are applied to the working set and the final store operation is performed."
    STORE
}

"Enumerates all policies of how to combine rule-based mode values with the effective field modes before rule application."
enum ModePolicy {
    "Ignore local mode attribute completely."
    IGNORE_LOCAL
    "Override if effective mode is be NORMAL"
    OVERRIDE
}

enum ResultType {
    DEFAULT
    ERROR
    INFO
    SILENT
    SUCCESS
    WARNING
}

"Domain object used in ext-filter-test. Generated from public.bar in the database dump."
input BarInput {
    created: Timestamp
    id: String!
    name: String!
    numa: Int!
    numb: Int!
}

"Associated Entity A (see BazLink)"
input BazInput {
    id: String!
    name: String!
    ownerId: String!
}

"Associative entity m-to-n connecting Baz and BazValue"
input BazLinkInput {
    bazId: String!
    id: String!
    valueId: String!
}

"Associated Entity B (see BazLink)"
input BazValueInput {
    id: String!
    name: String!
}

"Generated for de.quinscape.automatontest.model.ComplexContainer"
input ComplexContainerInput {
    foo: FooInput
    other: NodeInput
}

"Many-to-many associated type to Corge"
input CorgeAssocInput {
    description: String
    id: String!
    name: String!
    num: Int!
    version: String!
}

"Type complex used in merge-test"
input CorgeInput {
    created: Timestamp!
    description: String
    flag: Boolean!
    id: String!
    modified: Timestamp!
    name: String!
    num: Int!
    num2: Int
    ownerId: String!
    type2: String!
    typeId: String!
    version: String!
}

"Many-to-many link type between Corge and CorgeAssoc"
input CorgeLinkInput {
    assocId: String!
    corgeId: String!
    id: String!
    version: String!
}

"Type of Corges, connected via relation"
input CorgeTypeInput {
    id: String!
    name: String!
}

"Encapsulates multiple changes for a single entity / domain object."
input EntityChangeInput {
    "List of changes"
    changes: [EntityFieldChangeInput]!
    "Id value of the entity/domain object"
    id: GenericScalar!
    new: Boolean
    "Domain type of the object"
    type: String!
    "Version of the entity/domain object"
    version: String
}

"Encapsulates the type and id of on object deletion in a working set."
input EntityDeletionInput {
    "Id of deleted object as generic scalar."
    id: GenericScalar!
    "Domain type of deleted object"
    type: String!
    version: String
}

"A change for one domain object field"
input EntityFieldChangeInput {
    "Field the change applies to"
    field: String!
    "Generic scalar value of the field. Must match the underlying GraphQL field type."
    value: GenericScalar
}

"Reference to a specific entity or entity version"
input EntityReferenceInput {
    id: GenericScalar!
    type: String!
    version: String
}

"Generic domain object. Used as target in datagrid-test. Generated from public.foo in the database dump."
input FooInput {
    created: Timestamp!
    description: String
    flag: Boolean!
    id: String!
    name: String!
    num: Int!
    ownerId: String!
    type: String!
}

"Container bean for the file/resource example."
input FredInput {
    items: [FredItemInput]
    name: String!
}

"Item within a Fred"
input FredItemInput {
    flag: Boolean
    name: String!
    value: Int
}

"Entity containing BigDecimal fields"
input GarplyInput {
    "garply id"
    id: String!
    "garply name"
    name: String!
    "optional big decimal field"
    opt: BigDecimal
    "big decimal field"
    value: BigDecimal!
}

"Generated for de.quinscape.automatontest.domain.tables.pojos.Grault"
input GraultInput {
    attachmentId: String
    id: String!
    name: String!
    url: String
}

"Container for user-editable interactive query definition. Wraps a query string and a default query config."
input InteractiveQueryDefinitionInput {
    query: String
    queryConfig: QueryConfigInput
}

"Generated for de.quinscape.automaton.model.merge.MergeConfig"
input MergeConfigInput {
    allowApply: Boolean
    allowDiscard: Boolean
    typeConfigs: [MergeTypeConfigInput]!
}

"A field within a merge conflict."
input MergeConflictFieldInput {
    """

    True if the conflict is only sent for informational purposes and for the "apply" function. It marks conflicts
    that are already resolved.
    """
    informational: Boolean
    name: String!
    "The user's value for the conflict."
    ours: GenericScalar
    """

    In case of a pseudo conflict on a many-to-many field this contains entity references to the current set of link
    type entities.
    """
    references: [EntityReferenceInput]
    "Field status for the conflict."
    status: MergeFieldStatus
    "The currently stored value for the conflict."
    theirs: GenericScalar
}

"A merge conflict for one entity."
input MergeConflictInput {
    "Returns true if all conflict fields are decided or if there are no conflict fields."
    decided: Boolean
    "True if the entity has been deleted on the other side"
    deleted: Boolean!
    """

    Conflicted fields. Will be both conflicts on scalar fields as well as conflicts on object fields representing
    foreign key and many-to-many conflicts and the informational/user-facing data to resolve those.
    """
    fields: [MergeConflictFieldInput]!
    "Id of the entity as generic scalar"
    id: GenericScalar!
    "The version of the currently stored entity."
    theirVersion: String
    "Type of the entity."
    type: String!
}

"Generated for de.quinscape.automaton.model.merge.MergeGroup"
input MergeGroupInput {
    fields: [String]!
}

input MergeTypeConfigInput {
    """

    List of fields that are ignored in the merge, i.e. the last value always wins. This is useful for
    meta-data fields like creation time or change author
    """
    ignored: [String]
    """

    List of field groups are that only merged together. A change in one field of a merge-group always creates a
    conflict
    for the whole group.
    """
    mergeGroups: [MergeGroupInput]
    name: String!
}

"Container type to test <FieldMetaButton/> on different field types"
input MetaConfigInput {
    attachmentId: String
    bigNum: BigDecimal
    corgeTypeId: String
    date: Date
    flag: Boolean
    id: String!
    name: String!
    num: Int
    text: String
    timestamp: Timestamp
    type: String
    url: String
}

"Recursive domain object used in animal-test. Generated from public.node in the database dump."
input NodeInput {
    id: String!
    name: String!
    parentId: String
    type: Int!
}

"Encapsulates all parameters of an interactive query."
input QueryConfigInput {
    "FilterDSL condition graph or null"
    condition: Condition
    "Optional unique query identifier. Useful for server-side query implementations."
    id: String
    "Current offset within the paginated results. The number of rows to skip in the results."
    offset: Int
    "Maximum number of paginated results.,"
    pageSize: Int
    "Current sort order for the query."
    sortFields: [FieldExpression]
}

"Catalog-like connected via id foreign key to QuxMain"
input QuxAInput {
    description: String
    id: String!
    name: String!
    value: Int!
}

"Catalog-like connected via name foreign key to QuxMain"
input QuxBInput {
    description: String
    id: String!
    name: String!
    value: Int!
}

"Catalog-like connected via id foreign keys to QuxMain twice"
input QuxCInput {
    description: String
    id: String!
    name: String!
    value: Int!
}

"Main object for fk_test"
input QuxMainInput {
    id: String!
    name: String!
    quxAId: String!
    quxBName: String
    quxCId1: String!
    quxCId2: String
    quxD2Id: String
    quxD3Id: String
    quxD4Id: String
    quxDId: String
}

input RuleFieldInput {
    length: Int
    "Returns the fixed mode for this field. How this mode is applied depends on the #modePolicy."
    mode: FieldMode
    modePolicy: ModePolicy
    name: String
    placeholder: String
    required: Boolean
    tooltip: String
    validations: [RuleFieldValidationInput]
}

"Generated for de.quinscape.automatontest.model.RuleFieldValidation"
input RuleFieldValidationInput {
    caseInsensitive: Boolean
    message: String
    multiLine: Boolean
    regexp: String
}

"Generated for de.quinscape.automatontest.model.Rule"
input RuleInput {
    fields: [RuleFieldInput]
    name: String
}

"Encapsulates the set of all named validation rules. Corresponds to the top-level rules.json file."
input ValidationRulesInput {
    _: String
    rules: [RuleInput]
    writable: Boolean
}

"Generated for de.quinscape.automatontest.domain.tables.pojos.Waldo"
input WaldoInput {
    date: Date!
    id: String!
    name: String!
    opt1: Timestamp
    opt2: Date
    timestamp: Timestamp!
}


"BigDecimal wrapped as string"
scalar BigDecimal

"Built-in Byte as Int"
scalar Byte

"Map graph representing JOOQ conditions"
scalar Condition

"SQL date equivalent"
scalar Date

"Container for generic domain objects as scalar"
scalar DomainObject

"Map graph representing a JOOQ field expression"
scalar FieldExpression

"Container for generic scalar values"
scalar GenericScalar

"Postgresql jsonb type equivalent"
scalar JSONB

"Long type"
scalar Long

"SQL timestamp equivalent"
scalar Timestamp
