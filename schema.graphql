# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: QueryType
    mutation: MutationType
}

"Generated from public.app_attachment"
type AppAttachment {
    "DB column 'content_id'"
    contentId: String
    "DB column 'description'"
    description: String
    "DB column 'id'"
    id: String!
    "DB column 'type'"
    type: String!
}

"Generated from public.app_config"
type AppConfig {
    "DB column 'name'"
    name: String!
    "DB column 'scope'"
    scope: JSONB!
}

"Generated from public.app_login"
type AppLogin {
    "DB column 'last_used'"
    lastUsed: Timestamp!
    "DB column 'series'"
    series: String!
    "DB column 'token'"
    token: String!
    "DB column 'username'"
    username: String!
}

"Generated from public.app_translation"
type AppTranslation {
    "DB column 'created'"
    created: Timestamp!
    "DB column 'id'"
    id: String!
    "DB column 'locale'"
    locale: String!
    "DB column 'modified'"
    modified: Timestamp!
    "DB column 'process_name'"
    processName: String!
    "DB column 'tag'"
    tag: String!
    "DB column 'translation'"
    translation: String!
}

"Generated from public.app_user"
type AppUser {
    "Many-to-many objects from baz.owner_id"
    bazes: [Baz]!
    "DB column 'created'"
    created: Timestamp!
    "DB column 'disabled'"
    disabled: Boolean
    "Many-to-many objects from foo.owner_id"
    foos: [Foo]!
    "DB column 'id'"
    id: String!
    "DB column 'last_login'"
    lastLogin: Timestamp
    "DB column 'login'"
    login: String!
    "DB column 'password'"
    password: String!
    "DB column 'roles'"
    roles: String!
}

"Generated from public.app_user_config"
type AppUserConfig {
    "DB column 'attachment_id'"
    attachmentId: String!
    "DB column 'login'"
    login: String!
    "DB column 'user_id'"
    userId: String!
}

"Stores merge version metadata"
type AppVersion {
    "Timestamp when the version was created"
    created: Timestamp!
    "DB column 'entity_id'"
    entityId: String!
    "DB column 'entity_type'"
    entityType: String!
    "DB column 'field_mask'"
    fieldMask: BigInteger!
    "Id of the version. Is the same as the version field in the entity."
    id: String!
    "Target of 'owner_id'"
    owner: AppUser!
    "DB foreign key column 'owner_id'"
    ownerId: String!
    "DB column 'prev'"
    prev: String
}

"Domain object used in ext-filter-test. Generated from public.bar in the database dump."
type Bar {
    "DB column 'created'"
    created: Timestamp
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "DB column 'numa'"
    numa: Int!
    "DB column 'numb'"
    numb: Int!
}

"Associated Entity A (see BazLink)"
type Baz {
    "Many-to-many objects from baz_link.baz_id"
    bazLinks: [BazLink]!
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "Target of 'owner_id'"
    owner: AppUser!
    "DB foreign key column 'owner_id'"
    ownerId: String!
}

"Associative entity m-to-n connecting Baz and BazValue"
type BazLink {
    "Target of 'baz_id'"
    baz: Baz!
    "DB foreign key column 'baz_id'"
    bazId: String!
    "DB column 'id'"
    id: String!
    "Target of 'value_id'"
    value: BazValue!
    "DB foreign key column 'value_id'"
    valueId: String!
}

"Associated Entity B (see BazLink)"
type BazValue {
    "Many-to-many objects from baz_link.value_id"
    bazLinks: [BazLink]!
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
}

"The state of a column within an interactive query."
type ColumnState {
    "True if column is enabled. Server might disabled columns."
    enabled: Boolean
    "Column name"
    name: String
    "True if the column is sortable."
    sortable: Boolean
}

"Type complex used in merge-test"
type Corge {
    "Many-to-many objects from corge_link.corge_id"
    corgeLinks: [CorgeLink]!
    "DB column 'created'"
    created: Timestamp!
    "DB column 'description'"
    description: String
    "DB column 'flag'"
    flag: Boolean!
    "DB column 'id'"
    id: String!
    "DB column 'modified'"
    modified: Timestamp!
    "DB column 'name'"
    name: String!
    "DB column 'num'"
    num: Int!
    "DB column 'num2'"
    num2: Int
    "Target of 'owner_id'"
    owner: AppUser!
    "DB foreign key column 'owner_id'"
    ownerId: String!
    "Target of 'type_id'"
    type: CorgeType!
    "DB column 'type2'"
    type2: String!
    "DB foreign key column 'type_id'"
    typeId: String!
    "DB column 'version'"
    version: String!
}

"Many-to-many associated type to Corge"
type CorgeAssoc {
    "DB column 'description'"
    description: String
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "DB column 'num'"
    num: Int!
    "DB column 'version'"
    version: String!
}

"Many-to-many link type between Corge and CorgeAssoc"
type CorgeLink {
    "Target of 'assoc_id'"
    assoc: CorgeAssoc!
    "DB foreign key column 'assoc_id'"
    assocId: String!
    "Target of 'corge_id'"
    corge: Corge!
    "DB foreign key column 'corge_id'"
    corgeId: String!
    "DB column 'id'"
    id: String!
    "DB column 'version'"
    version: String!
}

"Type of Corges, connected via relation"
type CorgeType {
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
}

"Reference to a specific entity or entity version"
type EntityReference {
    id: GenericScalar!
    type: String!
    version: String
}

"Generic domain object. Used as target in datagrid-test. Generated from public.foo in the database dump."
type Foo {
    "DB column 'created'"
    created: Timestamp!
    "DB column 'description'"
    description: String
    "DB column 'flag'"
    flag: Boolean!
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "DB column 'num'"
    num: Int!
    "Target of 'owner_id'"
    owner: AppUser!
    "DB foreign key column 'owner_id'"
    ownerId: String!
    "DB foreign key column 'type'"
    type: String!
}

"Catalog-like domain object, referenced by Foo. Generated from public.foo_type in the database dump."
type FooType {
    "DB column 'name'"
    name: String!
    "DB column 'ordinal'"
    ordinal: Int!
}

"Generated from public.grid_columns"
type GridColumns {
    "DB column 'columns'"
    columns: JSONB
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "DB column 'owner_id'"
    ownerId: String!
}

"Interactive Query with AppUser payload."
type InteractiveQueryAppUser {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of AppUser."
    rows: [AppUser]
    "Name of payload type (always 'AppUser')"
    type: String
}

"Interactive Query with Bar payload."
type InteractiveQueryBar {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of Bar."
    rows: [Bar]
    "Name of payload type (always 'Bar')"
    type: String
}

"Interactive Query with Baz payload."
type InteractiveQueryBaz {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of Baz."
    rows: [Baz]
    "Name of payload type (always 'Baz')"
    type: String
}

"Interactive Query with BazLink payload."
type InteractiveQueryBazLink {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of BazLink."
    rows: [BazLink]
    "Name of payload type (always 'BazLink')"
    type: String
}

"Interactive Query with BazValue payload."
type InteractiveQueryBazValue {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of BazValue."
    rows: [BazValue]
    "Name of payload type (always 'BazValue')"
    type: String
}

"Interactive Query with Corge payload."
type InteractiveQueryCorge {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of Corge."
    rows: [Corge]
    "Name of payload type (always 'Corge')"
    type: String
}

"Interactive Query with CorgeAssoc payload."
type InteractiveQueryCorgeAssoc {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of CorgeAssoc."
    rows: [CorgeAssoc]
    "Name of payload type (always 'CorgeAssoc')"
    type: String
}

"Interactive Query with CorgeLink payload."
type InteractiveQueryCorgeLink {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of CorgeLink."
    rows: [CorgeLink]
    "Name of payload type (always 'CorgeLink')"
    type: String
}

"Interactive Query with CorgeType payload."
type InteractiveQueryCorgeType {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of CorgeType."
    rows: [CorgeType]
    "Name of payload type (always 'CorgeType')"
    type: String
}

"Interactive Query with Foo payload."
type InteractiveQueryFoo {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of Foo."
    rows: [Foo]
    "Name of payload type (always 'Foo')"
    type: String
}

"Interactive Query with FooType payload."
type InteractiveQueryFooType {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of FooType."
    rows: [FooType]
    "Name of payload type (always 'FooType')"
    type: String
}

"Interactive Query with Node payload."
type InteractiveQueryNode {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of Node."
    rows: [Node]
    "Name of payload type (always 'Node')"
    type: String
}

"Interactive Query with QuxA payload."
type InteractiveQueryQuxA {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of QuxA."
    rows: [QuxA]
    "Name of payload type (always 'QuxA')"
    type: String
}

"Interactive Query with QuxB payload."
type InteractiveQueryQuxB {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of QuxB."
    rows: [QuxB]
    "Name of payload type (always 'QuxB')"
    type: String
}

"Interactive Query with QuxC payload."
type InteractiveQueryQuxC {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of QuxC."
    rows: [QuxC]
    "Name of payload type (always 'QuxC')"
    type: String
}

"Interactive Query with QuxD payload."
type InteractiveQueryQuxD {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of QuxD."
    rows: [QuxD]
    "Name of payload type (always 'QuxD')"
    type: String
}

"Interactive Query with QuxMain payload."
type InteractiveQueryQuxMain {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of QuxMain."
    rows: [QuxMain]
    "Name of payload type (always 'QuxMain')"
    type: String
}

"Interactive Query with SumPerMonth payload."
type InteractiveQuerySumPerMonth {
    "Column states for the current result."
    columnStates: [ColumnState]
    "Query configuration the current result was produced with."
    queryConfig: QueryConfig
    "Total row count available."
    rowCount: Int
    "List with current rows of SumPerMonth."
    rows: [SumPerMonth]
    "Name of payload type (always 'SumPerMonth')"
    type: String
}

"A merge conflict for one entity."
type MergeConflict {
    "Returns true if all conflict fields are decided or if there are no conflict fields."
    decided: Boolean
    "True if the entity has been deleted on the other side"
    deleted: Boolean!
    """

    Conflicted fields. Will be both conflicts on scalar fields as well as conflicts on object fields representing
    foreign key and many-to-many conflicts and the informational/user-facing data to resolve those.
    """
    fields: [MergeConflictField]!
    "Id of the entity as generic scalar"
    id: GenericScalar!
    "The version of the currently stored entity."
    theirVersion: String
    "Type of the entity."
    type: String!
}

"A field within a merge conflict."
type MergeConflictField {
    """

    True if the conflict is only sent for informational purposes and for the "apply" function. It marks conflicts
    that are already resolved.
    """
    informational: Boolean
    name: String!
    "The user's value for the conflict."
    ours: GenericScalar
    """

    In case of a pseudo conflict on a many-to-many field this contains entity references to the current set of link
    type entities.
    """
    references: [EntityReference]
    """

    Field status for the conflict. If MergeOptions#isAllowAutoMerge() is enabled, this will always be MergeFieldStatus#UNDECIDED, if auto-merge
    is disabled, the system will report back successful merges with the respective choices made.
    """
    status: MergeFieldStatus
    "The currently stored value for the conflict."
    theirs: GenericScalar
}

"Encapsulates the result of a merge operation. Used in-memory on the client-side."
type MergeResolution {
    "Operation selected by the user."
    operation: MergeResolutionOperation
    "Resolutions to apply to the working set."
    resolutions: [MergeResolutionEntity]!
}

"Encapsulates the merge resolution for one of the entities involved. Used in-memory on the client-side."
type MergeResolutionEntity {
    deleted: Boolean!
    fields: [MergeResolutionField]!
    id: GenericScalar!
    type: String!
    version: String
}

"Encapsulates the merge resolution of a single field. Used in-memory on the client-side."
type MergeResolutionField {
    fieldType: MergeResolutionFieldType
    "GraphQL name of the field."
    name: String!
    status: MergeFieldStatus!
    "Wrapped value"
    value: GenericScalar
}

"Encapsulates the result of a merge process, i.e. a list of domain object conflicts."
type MergeResult {
    conflicts: [MergeConflict]!
    "Returns true when the merge is done because there were no conflicts."
    done: Boolean
}

"Auto-generated from DataGridLogic, ShippingLogic, TestLogic, AutomatonStandardLogic"
type MutationType {
    complexStore(container: ComplexContainerInput): Boolean
    "Example for Datagrid column configuration. Stores columns in public.grid_columns"
    configureColumns(columns: JSONB, name: String!): Boolean
    createFoo(name: String!): Foo
    "Deletes the domain object of the given type and with the given id."
    deleteDomainObject(cascade: [String], id: GenericScalar!, type: String!): Boolean
    "Generate a new domain object id using the application specific IdGenerator implementation."
    generateDomainObjectId(count: Int = 1, domainType: String!): [GenericScalar]
    "Server-side end-point for WorkingSet.merge()"
    mergeWorkingSet(changes: [EntityChangeInput]!, deletions: [EntityDeletionInput]!, mergeConfig: MergeConfigInput): MergeResult
    "Server-side end-point for WorkingSet.persist()"
    persistWorkingSet(deletions: [EntityDeletionInput]!, domainObjects: [DomainObject]!): Boolean
    "Dummy end-point to define the types involved in resolving a merge conflict, which happens on the client side only. This is only exists for documentation purposes."
    resolveMerge(mergeConfig: MergeConfigInput, mergeConflict: MergeConflictInput): MergeResolution
    "Stores a single domain object of any type. Note that you might have to manually register an input type."
    storeDomainObject(domainObject: DomainObject!): GenericScalar
    "Stores a list of domain object of any type. Note that you might have to manually register an input type."
    storeDomainObjects(domainObjects: [DomainObject]!): [GenericScalar]
    "Updates the associations of one source domain object over a many-to-many connection / an associative entity"
    updateAssociations(domainObjects: [DomainObject]!, domainType: String!, leftSideRelation: String!, sourceIds: [GenericScalar]!): [GenericScalar]
    wireTestMutation(count: Int, input: FooInput): WireTestResult
}

"Recursive domain object used in animal-test. Generated from public.node in the database dump."
type Node {
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "Target of 'parent_id'"
    parent: Node
    "DB column 'type'"
    type: Int!
}

"Generated for de.quinscape.domainql.util.Paged<Foo>"
type PagedFoo {
    rowCount: Int!
    rows: [Foo]!
}

"Encapsulates all parameters of an interactive query."
type QueryConfig {
    "FilterDSL condition graph or null"
    condition: Condition
    "Optional unique query identifier. Useful for server-side query implementations."
    id: String
    "Current offset within the paginated results. The number of rows to skip in the results."
    offset: Int
    "Maximum number of paginated results.,"
    pageSize: Int
    "Current sort order for the query."
    sortFields: [FieldExpression]
}

"Auto-generated from DataGridLogic, ShippingLogic, TestLogic, AutomatonStandardLogic"
type QueryType {
    getDomainTypeIndex(condition: Condition, domainType: String!, field: String!): [String]
    getFoos(limit: Int = 10, offset: Int = 0): PagedFoo
    "Queries AppUser objects based on the given query config"
    iQueryAppUser(config: QueryConfigInput!): InteractiveQueryAppUser
    "Queries Bar objects based on the given query config"
    iQueryBar(config: QueryConfigInput!): InteractiveQueryBar
    "Queries Baz objects based on the given query config"
    iQueryBaz(config: QueryConfigInput!): InteractiveQueryBaz
    "Queries BazLink objects based on the given query config"
    iQueryBazLink(config: QueryConfigInput!): InteractiveQueryBazLink
    "Queries BazValue objects based on the given query config"
    iQueryBazValue(config: QueryConfigInput!): InteractiveQueryBazValue
    "Queries Corge objects based on the given query config"
    iQueryCorge(config: QueryConfigInput!): InteractiveQueryCorge
    "Queries CorgeAssoc objects based on the given query config"
    iQueryCorgeAssoc(config: QueryConfigInput!): InteractiveQueryCorgeAssoc
    "Queries CorgeLink objects based on the given query config"
    iQueryCorgeLink(config: QueryConfigInput!): InteractiveQueryCorgeLink
    "Queries CorgeType objects based on the given query config"
    iQueryCorgeType(config: QueryConfigInput!): InteractiveQueryCorgeType
    "Queries Foo objects based on the given query config"
    iQueryFoo(config: QueryConfigInput!): InteractiveQueryFoo
    "Queries FooType objects based on the given query config"
    iQueryFooType(config: QueryConfigInput!): InteractiveQueryFooType
    "Queries Node objects based on the given query config"
    iQueryNode(config: QueryConfigInput!): InteractiveQueryNode
    "Queries QuxA objects based on the given query config"
    iQueryQuxA(config: QueryConfigInput!): InteractiveQueryQuxA
    "Queries QuxB objects based on the given query config"
    iQueryQuxB(config: QueryConfigInput!): InteractiveQueryQuxB
    "Queries QuxC objects based on the given query config"
    iQueryQuxC(config: QueryConfigInput!): InteractiveQueryQuxC
    "Queries QuxD objects based on the given query config"
    iQueryQuxD(config: QueryConfigInput!): InteractiveQueryQuxD
    "Queries QuxMain objects based on the given query config"
    iQueryQuxMain(config: QueryConfigInput!): InteractiveQueryQuxMain
    "Queries SumPerMonth objects based on the given query config"
    iQuerySumPerMonth(config: QueryConfigInput!): InteractiveQuerySumPerMonth
    iQuerywithColumnConfigFoo(config: QueryConfigInput): InteractiveQueryFoo
    queryWithComplexList: [Foo]
    queryWithList: [Int]
    queryWithScalar: Timestamp
}

"Catalog-like connected via id foreign key to QuxMain"
type QuxA {
    "DB column 'description'"
    description: String
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "DB column 'value'"
    value: Int!
}

"Catalog-like connected via name foreign key to QuxMain"
type QuxB {
    "DB column 'description'"
    description: String
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "DB column 'value'"
    value: Int!
}

"Catalog-like connected via id foreign keys to QuxMain twice"
type QuxC {
    "DB column 'description'"
    description: String
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "DB column 'value'"
    value: Int!
}

"Catalog-like connected via id foreign QuxMain without scalar field"
type QuxD {
    "DB column 'description'"
    description: String
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "DB column 'value'"
    value: Int!
}

"Main object for fk_test"
type QuxMain {
    "DB column 'id'"
    id: String!
    "DB column 'name'"
    name: String!
    "Target of 'qux_a_id'"
    quxA: QuxA!
    "DB foreign key column 'qux_a_id'"
    quxAId: String!
    "Target of 'qux_b_name'"
    quxB: QuxB
    "DB foreign key column 'qux_b_name'"
    quxBName: String
    "Target of 'qux_c_id1'"
    quxC1: QuxC!
    "Target of 'qux_c_id2'"
    quxC2: QuxC
    "DB foreign key column 'qux_c_id1'"
    quxCId1: String!
    "DB foreign key column 'qux_c_id2'"
    quxCId2: String
    "Target of 'qux_d_id'"
    quxD: QuxD
}

"Domain object from Java POJO de.quinscape.automatontest.model.SumPerMonth shaped like the sum_per_month view in the database dump"
type SumPerMonth {
    "DB column 'month'"
    month: Int
    "DB column 'sum'"
    sum: Long
    "DB column 'year'"
    year: Int
}

"Generated for de.quinscape.automatontest.runtime.service.TestLogic$WireTestResult"
type WireTestResult {
    check: String
    created: Timestamp
    id: String
}

enum FieldMode {
    DISABLED
    INVISIBLE
    NORMAL
    PLAIN_TEXT
    READ_ONLY
}

enum MergeFieldStatus {
    "We took the original value."
    OURS
    "We took over the current database value"
    THEIRS
    "User has not yet decided."
    UNDECIDED
    "The user specified an alternate third value."
    VALUE
}

enum MergeResolutionFieldType {
    "Normal input field"
    FIELD
    "Foreign key raw key id field"
    FK_KEY
    "Embedded object for a foreign key"
    FK_OBJECT
    "Ignored field"
    IGNORE
    "Embedded list of objects for a m-to-n relation"
    MANY_TO_MANY
}

"User selected operation for a merge"
enum MergeResolutionOperation {
    """

    The merge resolutions are to be applied without executing the final store operation. The user can inspect the merge
    result in the original form context.
    """
    APPLY
    "The store operation was canceled. The working set remains as-is."
    CANCEL
    "The whole process is aborted and the current working set data is to be discarded."
    DISCARD
    "Merge resolutions are applied to the working set and the final store operation is performed."
    STORE
}

"Enumerates all policies of how to combine rule-based mode values with the effective field modes before rule application."
enum ModePolicy {
    "Ignore local mode attribute completely."
    IGNORE_LOCAL
    "Override if effective mode is be NORMAL"
    OVERRIDE
}

"Domain object used in ext-filter-test. Generated from public.bar in the database dump."
input BarInput {
    created: Timestamp
    id: String!
    name: String!
    numa: Int!
    numb: Int!
}

"Associated Entity A (see BazLink)"
input BazInput {
    id: String!
    name: String!
    ownerId: String!
}

"Associative entity m-to-n connecting Baz and BazValue"
input BazLinkInput {
    bazId: String!
    id: String!
    valueId: String!
}

"Associated Entity B (see BazLink)"
input BazValueInput {
    id: String!
    name: String!
}

"Generated for de.quinscape.automatontest.model.ComplexContainer"
input ComplexContainerInput {
    foo: FooInput
    other: NodeInput
}

"Many-to-many associated type to Corge"
input CorgeAssocInput {
    description: String
    id: String!
    name: String!
    num: Int!
    version: String!
}

"Type complex used in merge-test"
input CorgeInput {
    created: Timestamp!
    description: String
    flag: Boolean!
    id: String!
    modified: Timestamp!
    name: String!
    num: Int!
    num2: Int
    ownerId: String!
    type2: String!
    typeId: String!
    version: String!
}

"Many-to-many link type between Corge and CorgeAssoc"
input CorgeLinkInput {
    assocId: String!
    corgeId: String!
    id: String!
    version: String!
}

"Type of Corges, connected via relation"
input CorgeTypeInput {
    id: String!
    name: String!
}

"Encapsulates multiple changes for a single entity / domain object."
input EntityChangeInput {
    "List of changes"
    changes: [EntityFieldChangeInput]!
    "Id value of the entity/domain object"
    id: GenericScalar!
    new: Boolean
    "Domain type of the object"
    type: String!
    "Version of the entity/domain object"
    version: String
}

"Encapsulates the type and id of on object deletion in a working set."
input EntityDeletionInput {
    "Id of deleted object as generic scalar."
    id: GenericScalar!
    "Domain type of deleted object"
    type: String!
    version: String
}

"A change for one domain object field"
input EntityFieldChangeInput {
    "Field the change applies to"
    field: String!
    "Generic scalar value of the field. Must match the underlying GraphQL field type."
    value: GenericScalar
}

"Reference to a specific entity or entity version"
input EntityReferenceInput {
    id: GenericScalar!
    type: String!
    version: String
}

"Generic domain object. Used as target in datagrid-test. Generated from public.foo in the database dump."
input FooInput {
    created: Timestamp!
    description: String
    flag: Boolean!
    id: String!
    name: String!
    num: Int!
    ownerId: String!
    type: String!
}

"Generated for de.quinscape.automaton.model.merge.MergeConfig"
input MergeConfigInput {
    allowApply: Boolean
    allowDiscard: Boolean
    typeConfigs: [MergeTypeConfigInput]!
}

"A field within a merge conflict."
input MergeConflictFieldInput {
    """

    True if the conflict is only sent for informational purposes and for the "apply" function. It marks conflicts
    that are already resolved.
    """
    informational: Boolean
    name: String!
    "The user's value for the conflict."
    ours: GenericScalar
    """

    In case of a pseudo conflict on a many-to-many field this contains entity references to the current set of link
    type entities.
    """
    references: [EntityReferenceInput]
    """

    Field status for the conflict. If MergeOptions#isAllowAutoMerge() is enabled, this will always be MergeFieldStatus#UNDECIDED, if auto-merge
    is disabled, the system will report back successful merges with the respective choices made.
    """
    status: MergeFieldStatus
    "The currently stored value for the conflict."
    theirs: GenericScalar
}

"A merge conflict for one entity."
input MergeConflictInput {
    "Returns true if all conflict fields are decided or if there are no conflict fields."
    decided: Boolean
    "True if the entity has been deleted on the other side"
    deleted: Boolean!
    """

    Conflicted fields. Will be both conflicts on scalar fields as well as conflicts on object fields representing
    foreign key and many-to-many conflicts and the informational/user-facing data to resolve those.
    """
    fields: [MergeConflictFieldInput]!
    "Id of the entity as generic scalar"
    id: GenericScalar!
    "The version of the currently stored entity."
    theirVersion: String
    "Type of the entity."
    type: String!
}

"Generated for de.quinscape.automaton.model.merge.MergeGroup"
input MergeGroupInput {
    fields: [String]!
}

input MergeTypeConfigInput {
    """

    List of fields that are ignored in the merge, i.e. the last value always wins. This is useful for
    meta-data fields like creation time or change author
    """
    ignored: [String]
    """

    List of field groups are that only merged together. A change in one field of a merge-group always creates a
    conflict
    for the whole group.
    """
    mergeGroups: [MergeGroupInput]
    name: String!
}

"Recursive domain object used in animal-test. Generated from public.node in the database dump."
input NodeInput {
    id: String!
    name: String!
    parentId: String
    type: Int!
}

"Encapsulates all parameters of an interactive query."
input QueryConfigInput {
    "FilterDSL condition graph or null"
    condition: Condition
    "Optional unique query identifier. Useful for server-side query implementations."
    id: String
    "Current offset within the paginated results. The number of rows to skip in the results."
    offset: Int
    "Maximum number of paginated results.,"
    pageSize: Int
    "Current sort order for the query."
    sortFields: [FieldExpression]
}

"Catalog-like connected via id foreign key to QuxMain"
input QuxAInput {
    description: String
    id: String!
    name: String!
    value: Int!
}

"Catalog-like connected via name foreign key to QuxMain"
input QuxBInput {
    description: String
    id: String!
    name: String!
    value: Int!
}

"Catalog-like connected via id foreign keys to QuxMain twice"
input QuxCInput {
    description: String
    id: String!
    name: String!
    value: Int!
}

"Main object for fk_test"
input QuxMainInput {
    id: String!
    name: String!
    quxAId: String!
    quxBName: String
    quxCId1: String!
    quxCId2: String
    quxDId: String
}

input RuleFieldInput {
    length: Int
    "Returns the fixed mode for this field. How this mode is applied depends on the #modePolicy."
    mode: FieldMode
    modePolicy: ModePolicy
    name: String
    placeholder: String
    required: Boolean
    tooltip: String
    validations: [RuleFieldValidationInput]
}

"Generated for de.quinscape.automatontest.model.RuleFieldValidation"
input RuleFieldValidationInput {
    caseInsensitive: Boolean
    message: String
    multiLine: Boolean
    regexp: String
}

"Generated for de.quinscape.automatontest.model.Rule"
input RuleInput {
    fields: [RuleFieldInput]
    name: String
}

"Encapsulates the set of all named validation rules. Corresponds to the top-level rules.json file."
input ValidationRulesInput {
    _: String
    rules: [RuleInput]
    writable: Boolean
}


"SQL timestamp equivalent"
scalar Timestamp

"Container for generic scalar values"
scalar GenericScalar

"Postgresql jsonb type equivalent"
scalar JSONB

"Container for generic domain objects as scalar"
scalar DomainObject

"Map graph representing a JOOQ field expression"
scalar FieldExpression

"Long type"
scalar Long

"Built-in java.math.BigInteger"
scalar BigInteger

"Map graph representing JOOQ conditions"
scalar Condition
